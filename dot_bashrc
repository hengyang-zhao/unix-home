# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# don't put duplicate lines or lines starting with space in the history.
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# unlimited command history
HISTSIZE=
HISTFILESIZE=

# add time stamp for history command
HISTTIMEFORMAT="%Y-%m-%d %T  "

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

alias -- -='cd ..'

alias c=__connect_screen
alias e='emacs'
alias f='fuser -v'
alias g='grep -in'
alias h='head'
alias j='jobs -l'
alias k='lookup'
alias l='ls -hltr'
alias n='sudo netstat -ntlp'
alias p='ps -ef'
alias s='less -R'
alias t='tail'
alias v='vim'

# graphical open shortcut
if [ `uname` == Linux ]; then
    alias o='xdg-open'
elif [ `uname` == Darwin ]; then
    alias o='open'
    alias ls='ls -G'
elif [ `uname` == FreeBSD ]; then
    alias o='xdg-open'
    alias ls='ls -G'
fi

# verbose and interactive moving, removing, copying
alias rm='rm -vi'
alias cp='cp -vi'
alias mv='mv -vi'
alias vi='vim'
alias emacs='emacs -nw'

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
    . /etc/bash_completion
fi

# my verbose command line prompt
PS1='$(

# save the return value of the last command
t=$?

# clear the previous terminal formatting
echo -ne "\[\e[0m\]"

# if you are root, then you get a red name
if [ $UID -eq 0 ]; then
    echo -ne "\[\e[1;31m\]\u@\h\[\e[0m\]"
else
    echo -ne "\[\e[32m\]\u@\h\[\e[0m\]"
fi

# time stamp
# echo -ne " \[\e[2m\]`date +\"%b-%d-%Y %T\"`\[\e[0m\]"

# if there are background jobs, give the total count
if [ \j -gt 0 ]; then
    echo -ne " \[\e[33m\]&\j\[\e[0m\]"
fi

# if this is not buttom level shell, give the depth
if [ $SHLVL -gt 1 ]; then
    echo -ne " \[\e[35m\]^$((SHLVL-1))\[\e[0m\]"

    # if we are in a (GNU) screen, tell it
    if [ -n "$STY" ]; then
        echo -ne " \[\e[36m\]*${STY#*.}*\[\e[0m\]"
    fi
fi

gbr=`git rev-parse --abbrev-ref HEAD 2>/dev/null`
if [ _"$gbr" != _ ]; then
    if [ "$gbr" = HEAD ]; then
        gbr=`git rev-parse HEAD 2>/dev/null | head -c8`
    fi
    groot=$(basename $(git rev-parse --show-toplevel))

    if [ ${#groot} -gt 12 ]; then
        groot="${groot: 0:8}\`${groot: -3:3}"
    fi
    echo -ne " \[\e[33m\]$groot[$gbr]\[\e[0m\]"
fi

# of course, print the current working directory
echo -ne " \[\e[1;34m\]\w\[\e[0m\]"

# if the return value is not OK, tell it
if [ $t -ne 0 ]; then
    echo -ne " \[\e[31m\]<$t>\[\e[0m\]"
fi

# finally a highlighted prompt symbol on a new line
if [ $UID -eq 0 ]; then
    echo -ne "\n\[\e[1m\]#\[\e[0m\] "
else
    echo -ne "\n\[\e[1m\]$\[\e[0m\] "
fi
)' # end of my prompt

# Umask
#
# /etc/profile sets 022, removing write perms to group + others.
# Set a more restrictive umask: i.e. no exec perms for others:
# umask 027
# Paranoid: neither group nor others have any perms:
# umask 077

# Functions
# This function defines a 'cd' replacement function capable of keeping,
# displaying and accessing history of visited directories, up to 10 entries.
# To use it, uncomment it, source this file and try 'cd --'.
# acd_func 1.0.5, 10-nov-2004
# Petar Marinov, http:/geocities.com/h2428, this is public domain
__cd_func()
{
  local x2 the_new_dir adir index
  local -i cnt

  if [[ $1 ==  "--" ]]; then
    dirs -v
    return 0
  fi

  the_new_dir=$1
  [[ -z $1 ]] && the_new_dir=$HOME

  if [[ ${the_new_dir:0:1} == '-' ]]; then
    #
    # Extract dir N from dirs
    index=${the_new_dir:1}
    [[ -z $index ]] && index=1
    adir=$(dirs +$index)
    [[ -z $adir ]] && return 1
    the_new_dir=$adir
  fi

  #
  # '~' has to be substituted by ${HOME}
  [[ ${the_new_dir:0:1} == '~' ]] && the_new_dir="${HOME}${the_new_dir:1}"

  #
  # Now change to the new dir and add to the top of the stack
  pushd "${the_new_dir}" > /dev/null
  [[ $? -ne 0 ]] && return 1
  the_new_dir=$(pwd)

  #
  # Trim down everything beyond 11th entry
  popd -n +11 2>/dev/null 1>/dev/null

  #
  # Remove any other occurence of this dir, skipping the top of the stack
  for ((cnt=1; cnt <= 10; cnt++)); do
    x2=$(dirs +${cnt} 2>/dev/null)
    [[ $? -ne 0 ]] && return 0
    [[ ${x2:0:1} == '~' ]] && x2="${HOME}${x2:1}"
    if [[ "${x2}" == "${the_new_dir}" ]]; then
      popd -n +$cnt 2>/dev/null 1>/dev/null
      cnt=cnt-1
    fi
  done

  return 0
}

__verbose_cd() {
    if __cd_func "$1"; then
        if [ "$1" != -- ]; then
            ls
        fi
    fi
}
alias cd='__verbose_cd'

__define() {
    if [ 0 -eq $# ]; then
        echo "usage: define <word>" >&2
        return 255
    fi
    declare e=`echo $'\033'[`;
    dict "$@" | \
        sed -e "s/\<\($1\)\>/${e}7;33m\1${e}0m/g" \
            -e "s/^\(From \)\(.*\):$/${e}1m\1${e}4m\2${e}0m${e}1m:${e}0m/g" | \
        less -r
}
alias d=__define

__bc_calc()
{
    if [ $# -eq 0 ]; then
        bc -l
        return
    fi
    if [ "$1" = "-h" ]; then
        echo "obase=16;ibase=16;$2" | bc -lq
        return
    fi
    if [ "$1" = "-h2d" ]; then
        echo "ibase=16;$2" | bc -lq
        return
    fi
    if [ "$1" = "-d2h" ]; then
        echo "obase=16;$2" | bc -lq
        return
    fi
    echo "$1" | bc -lq
}
alias b=__bc_calc

__maxima_calc()
{
    if [ $# -eq 0 ]; then
        maxima
        return
    fi
    maxima -b $1
    #maxima --very-quiet -r "$1\;"
}
alias m=__maxima_calc

__start_vm()
{
    if ! [ $1 ]; then
        echo "usage: __start_vm <guest-name>"
        return 1
    fi

    vboxmanage list vms | grep "\<$1\>" &> /dev/null
    if ! [ 0 = $? ]; then
        echo virtualbox guest "$1" does not exist.
        return -1
    fi

    __query_vm "$1" &> /dev/null
    if [ 0 = $? ]; then
        echo virtualbox guest "$1" is already running.
    else
        vboxmanage startvm "$1" --type headless
    fi
}

__stop_vm()
{
    if ! [ $1 ]; then
        echo "usage: __stop_vm <guest-name>"
        return 1
    fi

    vboxmanage list vms | grep "\<$1\>" &> /dev/null
    if ! [ 0 = $? ]; then
        echo virtualbox guest "$1" does not exist.
        return -1
    fi

    __query_vm "$1" &> /dev/null
    if [ 0 = $? ]; then

        for i in {20..1}; do

            vboxmanage controlvm "$1" acpipowerbutton &> /dev/null
            __query_vm "$1" &> /dev/null
            if [ 0 = $? ]; then
                echo waiting for guest $1 to stop "($i times to retry)"
                sleep 5
            else
                echo guest $1 is stopped.
                return 0
            fi
        done

        echo force shutting down guest $1...
        vboxmanage controlvm "$1" poweroff &> /dev/null
        __query_vm "$1"

    else
        echo virtualbox guest "$1" is already stopped.
    fi
}

__query_vm()
{
    if ! [ $1 ]; then
        echo $'\033[1m'---- registered guests ----$'\033[0m'
        vboxmanage list vms
        echo $'\033[1m'---- running guests ----$'\033[0m'
        vboxmanage list runningvms
        return 0
    fi

    vboxmanage list vms | grep "\<$1\>" &> /dev/null
    if ! [ 0 = $? ]; then
        echo virtualbox guest "$1" does not exist.
        return -1
    fi

    vboxmanage list runningvms | grep "\<$1\>" &> /dev/null
    if [ 0 = $? ]; then
        echo virtualbox guest "$1" is running.
        return 0
    else
        echo virtualbox guest "$1" is stopped.
        return 1
    fi
}
alias lsvm='__query_vm'

__red_stderr()
{
    #($@ 999>&1 1>&2 2>&999 999>&- | sed -e 's/\(^.*$\)/'$'\033''[31m\1'$'\033''[0m/g')
    #($@ 999>&1 1>&2 2>&999 999>&- | (sed -e 's/\(^.*$\)/'$'\033''[31m\1'$'\033''[0m/g' 1>&2)) #999>&1 1>&2 2>&999 999>&-
    $@ 2> >(sed -e 's/\(^.*$\)/'$'\033''[31m\1'$'\033''[0m/g' 1>&2)
}

__connect_screen()
{
    if test "_$1" = "_"; then
        screen -x main || screen -S main
    elif test "_$1" = "_-"; then
        screen -ls
    elif test "_$1" = "_^"; then
        sname=`__connect_screen - | head -2 | tail -1 | cut -f2`
        echo ${sname}
        sname="${sname#"${sname%%[![:space:]]*}"}"   # remove leading whitespace characters
        sname="${sname%"${sname##*[![:space:]]}"}"   # remove trailing whitespace characters
        echo ${sname}
        if test "_${sname}" = "_"; then
            echo "No background screen available."
        else
            __connect_screen ${sname}
        fi
    else
        screen -x $1 || screen -S $1
    fi
}

# vim: set ft=sh:

